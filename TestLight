# ue_lighting_tool_pyside6_skycolor_fixed.py
# Unreal Engine 5.6 Lighting Tool using PySide6
# Features: RGB Light Control, Intensity, Time of Day, Atmospherics, Sky Color, Safe UE Integration

from PySide6 import QtWidgets, QtCore, QtGui
import math, sys

# Try Unreal import
try:
    import unreal
    UNREAL_AVAILABLE = True
    unreal.log("üîÜ UE Lighting Tool script loaded successfully.")
except Exception:
    UNREAL_AVAILABLE = False
    print("‚ö†Ô∏è Unreal not detected ‚Äî running standalone preview mode.")


# ---------------- Unreal Helper ----------------
class UnrealFacade:
    """Handles all Unreal communication safely"""
    def __init__(self):
        if not UNREAL_AVAILABLE:
            return
        self.editor_level_lib = unreal.EditorLevelLibrary
        self.actors = self.editor_level_lib.get_all_level_actors()
        self.directional = self._find_actor("DirectionalLight")
        self.skylight = self._find_actor("SkyLight")
        self.fog = self._find_actor("ExponentialHeightFog")
        self.sky_atmos = self._find_actor("SkyAtmosphere")

    def _find_actor(self, name_part):
        for a in self.actors:
            if name_part.lower() in a.get_class().get_name().lower():
                return a
        return None

    def apply_directional_light(self, color_rgb, intensity, time_hours):
        if not UNREAL_AVAILABLE or not self.directional:
            return False, "Directional Light not found."
        try:
            comps = self.directional.get_components_by_class(unreal.LightComponentBase)
            if not comps:
                return False, "DirectionalLightComponent missing."
            light = comps[0]
            lc = unreal.LinearColor(color_rgb[0]/255, color_rgb[1]/255, color_rgb[2]/255, 1)
            if hasattr(light, "set_light_color"):
                light.set_light_color(lc, True)
            else:
                light.set_editor_property("light_color", lc)
            light.set_editor_property("intensity", float(intensity))

            # Rotate to simulate time of day
            pitch = (time_hours / 24.0) * 160.0 - 80.0
            yaw = self.directional.get_actor_rotation().yaw
            self.directional.set_actor_rotation(unreal.Rotator(pitch, yaw, 0), sweep=False, teleport=True)
            return True, "Directional light updated."
        except Exception as e:
            if UNREAL_AVAILABLE:
                unreal.log_warning(f"[LightingTool] Error updating directional: {e}")
            return False, str(e)

    def apply_sky_color(self, color_rgb):
        if not UNREAL_AVAILABLE:
            return False, "Unreal not available."
        r, g, b = [c / 255.0 for c in color_rgb]
        try:
            if self.skylight:
                comps = self.skylight.get_components_by_class(unreal.SkyLightComponent)
                if comps:
                    comp = comps[0]
                    comp.set_editor_property("light_color", unreal.LinearColor(r, g, b, 1))
                    unreal.log(f"[LightingTool] SkyLight color set to {r:.2f},{g:.2f},{b:.2f}")
                    return True, "SkyLight color updated."
            elif self.sky_atmos:
                comps = self.sky_atmos.get_components_by_class(unreal.SkyAtmosphereComponent)
                if comps:
                    comp = comps[0]
                    comp.set_editor_property("ground_albedo", unreal.LinearColor(r, g, b, 1))
                    unreal.log(f"[LightingTool] SkyAtmosphere tint updated.")
                    return True, "SkyAtmosphere tint updated."
            else:
                return False, "No SkyLight or SkyAtmosphere found."
        except Exception as e:
            unreal.log_warning(f"[LightingTool] Sky color apply failed: {e}")
            return False, str(e)

    def apply_atmospherics(self, atmos_value):
        if not UNREAL_AVAILABLE:
            return False, "Unreal not available."
        try:
            if self.fog:
                comps = self.fog.get_components_by_class(unreal.ExponentialHeightFogComponent)
                if comps:
                    fog_comp = comps[0]
                    fog_comp.set_editor_property("fog_density", float(atmos_value * 0.05))
            if self.sky_atmos:
                comps = self.sky_atmos.get_components_by_class(unreal.SkyAtmosphereComponent)
                if comps:
                    c = comps[0]
                    if hasattr(c, "aerial_perspective_view_distance_scale"):
                        c.set_editor_property("aerial_perspective_view_distance_scale", 1.0 + atmos_value * 2.0)
            return True, "Atmosphere updated."
        except Exception as e:
            unreal.log_warning(f"[LightingTool] Atmosphere update failed: {e}")
            return False, str(e)


# ---------------- Preview Widget ----------------
class PreviewWidget(QtWidgets.QWidget):
    """Simple day/night + sky preview"""
    def __init__(self):
        super().__init__()
        self.sun_color = QtGui.QColor(255, 200, 120)
        self.sky_color = QtGui.QColor(140, 180, 255)
        self.time_hours = 12.0
        self.atmos_value = 0.1
        self.setMinimumHeight(140)

    def set_values(self, sun_color, sky_color, time_hours, atmos):
        self.sun_color = QtGui.QColor(*sun_color)
        self.sky_color = QtGui.QColor(*sky_color)
        self.time_hours = time_hours
        self.atmos_value = atmos
        self.update()

    def paintEvent(self, _):
        w, h = self.width(), self.height()
        p = QtGui.QPainter(self)

        # Brightness curve (noon = brightest)
        t = (math.cos((self.time_hours - 12) / 24.0 * 2 * math.pi) + 1) / 2

        # Determine sky tint (sunrise/sunset)
        base_hue = self.sky_color.hueF() if self.sky_color.isValid() else 0.58
        base_sat = self.sky_color.saturationF() if self.sky_color.isValid() else 0.5
        base_val = self.sky_color.valueF() if self.sky_color.isValid() else 0.8

        if 5 <= self.time_hours <= 8:
            top_color = QtGui.QColor.fromHsvF(0.08, 0.6, 0.9)
            bottom_color = QtGui.QColor.fromHsvF(0.12, 0.5, 0.8)
        elif 18 <= self.time_hours <= 21:
            top_color = QtGui.QColor.fromHsvF(0.85, 0.5, 0.8)
            bottom_color = QtGui.QColor.fromHsvF(0.9, 0.4, 0.7)
        else:
            top_color = QtGui.QColor.fromHsvF(base_hue, base_sat, base_val * (0.4 + 0.6 * t))
            bottom_color = QtGui.QColor.fromHsvF(base_hue, base_sat * 0.8, base_val * (0.5 + 0.4 * t))

        grad = QtGui.QLinearGradient(0, 0, 0, h)
        grad.setColorAt(0, top_color)
        grad.setColorAt(1, bottom_color)
        p.fillRect(0, 0, w, h, QtGui.QBrush(grad))

        # Draw sun
        sun_x = int((self.time_hours / 24.0) * w)
        sun_y = int(h * (0.7 - 0.5 * math.sin((self.time_hours / 24.0) * math.pi)))
        r = 14
        g = QtGui.QRadialGradient(QtCore.QPointF(sun_x, sun_y), r * 2)
        g.setColorAt(0.0, self.sun_color)
        outer = QtGui.QColor(self.sun_color)
        outer.setAlpha(60)
        g.setColorAt(1.0, outer)
        p.setBrush(QtGui.QBrush(g))
        p.setPen(QtCore.Qt.NoPen)
        p.drawEllipse(sun_x - r, sun_y - r, r * 2, r * 2)

        # Fog overlay
        if self.atmos_value > 0:
            fog = QtGui.QColor(230, 230, 230, int(self.atmos_value * 200))
            p.fillRect(0, 0, w, h, fog)
        p.end()


# ---------------- Main Tool ----------------
class LightingTool(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("UE5.6 Lighting Tool ‚Äî Sky Color Edition")
        self.resize(440, 700)
        self.unreal = UnrealFacade() if UNREAL_AVAILABLE else None

        central = QtWidgets.QWidget()
        self.setCentralWidget(central)
        v = QtWidgets.QVBoxLayout(central)
        form = QtWidgets.QFormLayout()
        v.addLayout(form)

        # Sun color sliders
        self.r = self._make_slider(255)
        self.g = self._make_slider(200)
        self.b = self._make_slider(120)
        form.addRow("Sun Red:", self.r)
        form.addRow("Sun Green:", self.g)
        form.addRow("Sun Blue:", self.b)

        # Sky color sliders
        self.sky_r = self._make_slider(150)
        self.sky_g = self._make_slider(180)
        self.sky_b = self._make_slider(255)
        form.addRow("Sky Red:", self.sky_r)
        form.addRow("Sky Green:", self.sky_g)
        form.addRow("Sky Blue:", self.sky_b)

        # Intensity, time, atmosphere
        self.intensity = self._make_slider(100000, 0, 500000)
        self.time = self._make_slider(120, 0, 240)
        self.atmos = self._make_slider(10, 0, 100)
        form.addRow("Intensity:", self.intensity)
        form.addRow("Time (h √ó10):", self.time)
        form.addRow("Atmospherics:", self.atmos)

        self.live_cb = QtWidgets.QCheckBox("Preview only (disable auto-apply)")
        self.live_cb.setChecked(True)
        form.addRow(self.live_cb)

        # Buttons
        h = QtWidgets.QHBoxLayout()
        self.apply = QtWidgets.QPushButton("Apply to UE World")
        self.apply.clicked.connect(self.apply_to_ue)
        self.preview_btn = QtWidgets.QPushButton("Update Preview")
        self.preview_btn.clicked.connect(self.update_preview)
        h.addWidget(self.apply)
        h.addWidget(self.preview_btn)
        v.addLayout(h)

        # Preview widget
        self.preview = PreviewWidget()
        v.addWidget(self.preview)

        for s in (self.r, self.g, self.b, self.sky_r, self.sky_g, self.sky_b, self.intensity, self.time, self.atmos):
            s.valueChanged.connect(self.live_update)

        self.update_preview()

    def _make_slider(self, default, mn=0, mx=255):
        s = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        s.setRange(mn, mx)
        s.setValue(default)
        return s

    def get_values(self):
        sun = (self.r.value(), self.g.value(), self.b.value())
        sky = (self.sky_r.value(), self.sky_g.value(), self.sky_b.value())
        intensity = self.intensity.value()
        time_h = self.time.value() / 10.0
        atmos = self.atmos.value() / 100.0
        return sun, sky, intensity, time_h, atmos

    def live_update(self):
        self.update_preview()
        if not self.live_cb.isChecked():
            self.apply_to_ue()

    def update_preview(self):
        sun, sky, intensity, time_h, atmos = self.get_values()
        self.preview.set_values(sun, sky, time_h, atmos)

    def apply_to_ue(self):
        if not UNREAL_AVAILABLE:
            QtWidgets.QMessageBox.warning(self, "Unreal Missing", "Run inside Unreal Editor Python environment.")
            return
        sun, sky, intensity, time_h, atmos = self.get_values()
        ok1, msg1 = self.unreal.apply_directional_light(sun, intensity, time_h)
        ok2, msg2 = self.unreal.apply_atmospherics(atmos)
        ok3, msg3 = self.unreal.apply_sky_color(sky)
        QtWidgets.QMessageBox.information(self, "Apply Results", f"{msg1}\n{msg2}\n{msg3}")


# ---------------- Safe Entry Point ----------------
window_ref = None  # keeps UE window alive

def main():
    global window_ref
    app = QtWidgets.QApplication.instance() or QtWidgets.QApplication(sys.argv)
    window_ref = LightingTool()
    window_ref.show()

    if UNREAL_AVAILABLE:
        unreal.log("‚úÖ Lighting Tool launched inside Unreal Editor.")

    # Don't block Unreal loop
    if not QtWidgets.QApplication.instance().startingUp():
        app.exec()
    return window_ref


if __name__ == "__main__":
    main()
